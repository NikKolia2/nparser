"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const TypescriptCompiler_1 = require("./TypescriptCompiler");
class ModuleResolver {
    constructor(id, presetCallerDirname = null, depth = 5) {
        this.TS_EXT = '.ts';
        this.JS_EXT = '.js';
        this.isSourceCode = false;
        this.id = id;
        this.presetCallerDirname = presetCallerDirname;
        this.callerStrIndex = depth;
    }
    getCallerDirname() {
        if (this.presetCallerDirname)
            return this.presetCallerDirname;
        const stackStr = new Error('Caller').stack;
        const callerLineStr = stackStr.split(os_1.default.EOL)[this.callerStrIndex].trim().replace('at ', '');
        const firstSplit = callerLineStr.split('(');
        let callerFilePath;
        if (firstSplit.length === 1) {
            callerFilePath = firstSplit[0].split(':')[0];
        }
        else {
            callerFilePath = callerLineStr.split('(')[1].split(')')[0].split(':')[0];
        }
        return path_1.default.dirname(callerFilePath);
    }
    resolveModule() {
        if (this.filename)
            return this.filename;
        const moduleFullPath = require.resolve(path_1.default.join(this.getCallerDirname(), this.id));
        const extension = path_1.default.extname(moduleFullPath);
        switch (extension) {
            case this.TS_EXT:
                {
                    const typescriptCompiler = new TypescriptCompiler_1.TypescriptCompiler(moduleFullPath);
                    this.filename = typescriptCompiler.run();
                    this.isSourceCode = true;
                }
                break;
            case this.JS_EXT:
                {
                    this.filename = moduleFullPath;
                    this.isSourceCode = false;
                }
                break;
            default: {
                throw new Error(`Invalid extension [${extension}]`);
            }
        }
        return this.filename;
    }
}
exports.ModuleResolver = ModuleResolver;
//# sourceMappingURL=ModuleResolver.js.map